# ДЗ 2

### Сделать в первой сессии новую таблицу и наполнить ее данными

```postgresql
CREATE TABLE IF NOT EXISTS public.trans_study (
	id serial4 PRIMARY KEY,
	value int4 NOT NULL
);

INSERT INTO public.trans_study
(value)
VALUES (100),
       (300)
;

SELECT * FROM public.trans_study;
```

| id | value |
|----|-------|
| 1  | 100   |
| 2  | 300   |

-----

### Посмотреть текущий уровень изоляции

```postgresql
SHOW TRANSACTION ISOLATION LEVEL;
```

| transaction_isolation |
|-----------------------|
| read committed        |

----

### Hачать новую транзакцию в обеих сессиях с дефолтным (не меняя) уровнем изоляции
В обеих сессиях выполняем следующую команду:
```postgresql
BEGIN;
```

-----

### B первой сессии добавить новую запись

```postgresql
INSERT INTO public.trans_study
(value)
VALUES (500)
;
```

----

### Сделать запрос на выбор всех записей во второй сессии

```postgresql
SELECT * FROM public.trans_study;
```

| id | value |
|----|-------|
| 1  | 100   |
| 2  | 300   |

----

### Видите ли вы новую запись и если да то почему?

Новую запись не видим, так как транзакция в первой сессии ещё не завершена коммитом изменений.
Уровень read committed позволяет читать только закоммиченные изменения сделанные в других сессиях.

----

### Завершить транзакцию в первом окне

```postgresql
COMMIT;
```

----

### Сделать запрос на выбор всех записей во второй сессии

```postgresql
SELECT * FROM public.trans_study;
```

| id | value |
|----|-------|
| 1  | 100   |
| 2  | 300   |
| 3  | 500   |

----

### Видите ли вы новую запись и если да то почему?

Новую запись видим, так как транзакция в первой сессии уже завершена коммитом изменений.
Уровень read committed позволяет читать закоммиченные изменения сделанные в других сессиях.

----

### Завершить транзакцию во второй сессии

```postgresql
COMMIT;
```

----

### Hачать новые транзакции, но уже на уровне repeatable read в ОБЕИХ сессиях
В обеих сессиях выполняем следующую команду:
```postgresql
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

-----

### B первой сессии добавить новую запись

```postgresql
INSERT INTO public.trans_study
(value)
VALUES (700)
;
```

----

### Сделать запрос на выбор всех записей во второй сессии

```postgresql
SELECT * FROM public.trans_study;
```

| id | value |
|----|-------|
| 1  | 100   |
| 2  | 300   |
| 3  | 500   |

----

### Видите ли вы новую запись и если да то почему?

Новую запись не видим, так как, во-певых, транзакция в первой сессии ещё не завершена коммитом изменений, 
а во-вторых, транзакция во второй сессии на уровне repeatable read ещё не завершена и она
не может видеть закоммиченные изменения из других сессий, пока не будет завершена.

----

### Завершить транзакцию в первом окне

```postgresql
COMMIT;
```

----

### Сделать запрос на выбор всех записей во второй сессии

```postgresql
SELECT * FROM public.trans_study;
```

| id | value |
|----|-------|
| 1  | 100   |
| 2  | 300   |
| 3  | 500   |

----

### Видите ли вы новую запись и если да то почему?

Новую запись не видим, так как транзакция во второй сессии на уровне repeatable read ещё не завершена и она
не может видеть закоммиченные изменения из других сессий, пока не будет завершена.

----

----

## Не по ДЗ, но не хватает для удовлетворения чувства завершённости
### Завершить транзакцию во второй сессии

```postgresql
COMMIT;
```

----

### Сделать запрос на выбор всех записей во второй сессии

```postgresql
SELECT * FROM public.trans_study;
```

| id | value |
|----|-------|
| 1  | 100   |
| 2  | 300   |
| 3  | 500   |
| 4  | 700   |

После завершения транзакции уровня repeatable read во второй сессии изменения зафиксированные в других сессиях
стали видны и во второй сессии.

----

